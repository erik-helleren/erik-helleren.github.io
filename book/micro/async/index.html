<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async Profiler - Java Performance Lecture Notes</title>
        
        


        <!-- Custom HTML head -->
        <meta name="author" value="Erik Helleren">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../favicon.png">
        
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        
        <link rel="stylesheet" href="../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Introductions</a></li><li class="chapter-item expanded "><a href="../../introduction/standards.html"><strong aria-hidden="true">2.</strong> Standards</a></li><li class="chapter-item expanded "><a href="../../introduction/keyTerms.html"><strong aria-hidden="true">3.</strong> Key Terms</a></li><li class="chapter-item expanded affix "><li class="part-title">Theory</li><li class="chapter-item expanded "><a href="../../theory/queueTheory/index.html"><strong aria-hidden="true">4.</strong> Queue Theory</a></li><li class="chapter-item expanded "><a href="../../theory/statsPrimer/index.html"><strong aria-hidden="true">5.</strong> Statistics Primer</a></li><li class="chapter-item expanded "><a href="../../theory/distributionAnalysis/index.html"><strong aria-hidden="true">6.</strong> Distribution analysis</a></li><li class="chapter-item expanded "><a href="../../theory/coordinatedOmission/index.html"><strong aria-hidden="true">7.</strong> Coordinated Omission</a></li><li class="chapter-item expanded affix "><li class="part-title">Hardware</li><li class="chapter-item expanded "><a href="../../hardware/highLevel/index.html"><strong aria-hidden="true">8.</strong> Computer Architecture: High Level</a></li><li class="chapter-item expanded "><a href="../../hardware/cpu.html"><strong aria-hidden="true">9.</strong> Computer Architecture: CPU Design</a></li><li class="chapter-item expanded "><a href="../../hardware/Cache.html"><strong aria-hidden="true">10.</strong> Computer Architecture: Cache, RAM, and Locality</a></li><li class="chapter-item expanded affix "><li class="part-title">Operating System</li><li class="chapter-item expanded "><a href="../../os/refresher/index.html"><strong aria-hidden="true">11.</strong> OS Refresher</a></li><li class="chapter-item expanded "><a href="../../os/numa/index.html"><strong aria-hidden="true">12.</strong> NUMA and Numa Control</a></li><li class="chapter-item expanded "><a href="../../os/scheduler/index.html"><strong aria-hidden="true">13.</strong> Working with the scheduler</a></li><li class="chapter-item expanded affix "><li class="part-title">Java</li><li class="chapter-item expanded "><a href="../../jvm/compile/index.html"><strong aria-hidden="true">14.</strong> Compiling, interpreting, and compiling again</a></li><li class="chapter-item expanded "><a href="../../jvm/jit/index.html"><strong aria-hidden="true">15.</strong> Investigating JIT</a></li><li class="chapter-item expanded "><a href="../../jvm/memory/index.html"><strong aria-hidden="true">16.</strong> Java and Memory</a></li><li class="chapter-item expanded affix "><li class="part-title">Microbenchmarking with JMH</li><li class="chapter-item expanded "><a href="../../micro/micro/index.html"><strong aria-hidden="true">17.</strong> Microbenchmarking</a></li><li class="chapter-item expanded "><a href="../../micro/jmhIntro/index.html"><strong aria-hidden="true">18.</strong> JMH: An introduction</a></li><li class="chapter-item expanded "><a href="../../micro/pitfalls/index.html"><strong aria-hidden="true">19.</strong> Pitfalls</a></li><li class="chapter-item expanded "><a href="../../micro/design/index.html"><strong aria-hidden="true">20.</strong> Designing good benchmarks</a></li><li class="chapter-item expanded "><a href="../../micro/deps/index.html"><strong aria-hidden="true">21.</strong> Dealing with dependencies</a></li><li class="chapter-item expanded "><a href="../../micro/coreProfilers/index.html"><strong aria-hidden="true">22.</strong> Core Profilers</a></li><li class="chapter-item expanded "><a href="../../micro/async/index.html" class="active"><strong aria-hidden="true">23.</strong> Async Profiler</a></li><li class="chapter-item expanded "><a href="../../micro/ci/index.html"><strong aria-hidden="true">24.</strong> Integrating into the CI</a></li><li class="chapter-item expanded affix "><li class="part-title">Performance Design Patterns</li><li class="chapter-item expanded "><a href="../../perfDesign/tools/index.html"><strong aria-hidden="true">25.</strong> Tools and Frameworks</a></li><li class="chapter-item expanded "><a href="../../perfDesign/design/index.html"><strong aria-hidden="true">26.</strong> Design Patterns</a></li><li class="chapter-item expanded "><a href="../../perfDesign/arch/index.html"><strong aria-hidden="true">27.</strong> Architecture Patterns</a></li><li class="chapter-item expanded affix "><li class="part-title">Component level benchmarks</li><li class="chapter-item expanded "><a href="../../comp/design/index.html"><strong aria-hidden="true">28.</strong> Test Design</a></li><li class="chapter-item expanded "><a href="../../comp/tooling/index.html"><strong aria-hidden="true">29.</strong> Available Tooling</a></li><li class="chapter-item expanded "><a href="../../comp/build/index.html"><strong aria-hidden="true">30.</strong> Build Your Own Tooling</a></li><li class="chapter-item expanded "><a href="../../comp/profiling/index.html"><strong aria-hidden="true">31.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="../../comp/instrumentation/index.html"><strong aria-hidden="true">32.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../../comp/model/index.html"><strong aria-hidden="true">33.</strong> Modeling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Java Performance Lecture Notes</h1>

                    <div class="right-buttons">
                        
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://www.buymeacoffee.com/erik.helleren" title="Buy Me A Coffee" aria-label="Buy Me A Coffe">
                            <i class="fa fa-coffee" aria-hidden="true"></i>
                        </a>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="jmh-async-profiler"><a class="header" href="#jmh-async-profiler">JMH: Async Profiler</a></h1>
<p>Async profiler deserves its own chapter given how powerful it is.  From <a href="https://github.com/jvm-profiling-tools/async-profiler">asynch-profiler's github page</a>:</p>
<blockquote>
<p>Short text answer. Most of the profilers are lying and/or having a lack of features: </p>
<ul>
<li>Instrumenting profilers - too slow, can't be used for production systems</li>
<li>Sampling profilers - sampling your program only at safe points. That might (and usually does) hide the real place where is an optimization should be applied. </li>
</ul>
<p>For more information see also this article: <a href="http://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">Why (Most) Sampling Java Profilers Are Not Good</a> </p>
</blockquote>
<p>To reframe, async profiler not only integrates into JMH natively.  When compared against a the best GUI profiler, async profiler has a much smaller observer effect, is super easy to use, and matches the capabilities when looking at CPU cycles, memory allocations, and lock contention.  Beyond those areas though, GUI profilers provide deeper features which may be useful, depending on your use case.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Unlike most things java, async profiler requires some extra setup on the system level because it has a native library.  The easiest way to get async profiler up and running is to download <a href="https://github.com/jvm-profiling-tools/async-profiler/releases">their latest release from here</a>.  If your preferred platform isn't available, just build from source by running this:</p>
<pre><code class="language-bash">mkdir ~/bin
cd ~/bin
git clone https://github.com/jvm-profiling-tools/async-profiler.git 
cd async-profiler
make
</code></pre>
<p>Above assumes you already have gcc (or xcode) installed and a JAVA_HOME env variable set.  It outputs the needed library to <code>~/bin/build/*asyncProfiler.*</code>, with the exact file name prefix and suffix is platform dependant.</p>
<p>Once you have the binary for your platform, you need to tell the JRE about it.  You can install it to your native java extensions location on your host.  On a mac that is <code>~/Library/Java/Extensions</code>.  Or just include the build directory on your LD_LIBRARY_PATH or DYLD_LIBRARY_PATH env variables.  If that fails, your last option is to explicitly tell JMH where the library is with <code>-prof async:path=/absolute/path/to/libasyncProfiler.dylib</code>.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h2>
<p>First, you can get help output for the async profiler using <code>java -jar target/benchmarks.jar -prof async:help</code>.  You can also refer to the <a href="https://github.com/jvm-profiling-tools/async-profiler/wiki">wiki for async-profiler</a>.</p>
<h2 id="how-to-use-async-profiler"><a class="header" href="#how-to-use-async-profiler">How to use Async Profiler</a></h2>
<p>Async profiler can be used via the command line to attach to a running java process quite easily by running <code>./build/profile.sh &lt;PID&gt;</code>.  You can also checkout <a href="https://github.com/jvm-profiling-tools/async-profiler/wiki/Basic-Usage">the basic usage</a> documentation as well.</p>
<p>If you are so inclined, you can also attach the profiler as an <a href="https://github.com/jvm-profiling-tools/async-profiler/wiki/Embedded-profiling-as-Java-Agent">agent</a>.  This is suitable for profiling startup code as well as for running profiling in production.</p>
<p>Lastly, JMH just has it built in as a profiler like the core profilers we just talked about.  This is what we will be focusing on in this chapter.</p>
<p>To make things a little more complicated, all 3 of these are configured in slightly different ways.  The rest of this chapter will focus on configuring async profiler for JMH.</p>
<h2 id="execution-time"><a class="header" href="#execution-time">Execution time</a></h2>
<p>So, lets run our first benchmark with async profiler.  Add <code>-prof async:output=flamegraph</code> to the program arguments and run your benchmark.  You will see a folder generated in your working directory named after your benchmarks class, method name, and parameters.  Inside that folder, we will see 2 files: <code>flame-cpu-forward.html</code> and <code>flame-cpu-reverse.html</code>.  <a href="http://www.brendangregg.com/flamegraphs.html">Flamegraphs</a> are a nice way to view data related to call trees. Its open source, based of human readable data, and can be viewed in any modern browsers very easily. </p>
<p>So we are going to start off by running a very basic benchmark, logging to info using log4j2 configured to synchronously print to the console.</p>
<pre><code class="language-java">    @Benchmark
    public void logToInfo(SomeState s, Blackhole bh) {
        s.logger.info(&quot;Lets just log something: {}&quot;, s.someInt++);
    }
</code></pre>
<p>Before we dive into the below flamegraph, I just want to highlight how async-profiler works when measuring CPU usage.  It takes periodic stack traces and produces aggregated output in one of several formats, one of which is a flamegraph. It hooks into the JVM to take samples of the stacktrace for application threads periodically.  With that said, it is quite good at avoiding coordinated omission.</p>
<p>I personally prefer flamegraphs because of their strong visuals, but they are just one way to view the data. Here is what a flamegraph looks like from the above benchmark.</p>
<iframe src="/micro/async/flame-cpu-forward.html" style="width:100%;height:400px;"></iframe>
<p>To get more samples, simply set the interval in the profiler setup like <code>-prof async:output=flamegraph;interval=20000</code>.  But just remember, the smaller the interval is in nanoseconds, the higher your observer effect becomes.  While this may be ok to have a very high sample rate for tests, it may not be for production.</p>
<h3 id="reading-the-flamegraph"><a class="header" href="#reading-the-flamegraph">Reading the flamegraph</a></h3>
<p>The wider the bar is, the more samples were in that method or one of the methods it calls.  As you move up the graph, you get deeper into the call stack until you get to the top.  The method at the top is always the method that the thread was at the time the stack trace was taken.</p>
<p>You can click to zoom in and out, search for a certain method, and flip the chart around.  When you hover over a method bar, you can see the number of samples that are included in that bar both in absolute terms and as a percentage of all samples. The color tells you what type of method you are in:</p>
<ul>
<li>Green is regular java code</li>
<li>Yellow is a native jvm method</li>
<li>Red is a non-jvm native method</li>
<li>Brown is OS kernel code</li>
</ul>
<p>Before moving on, investigate the above flamegraph and see if you what is weird.  What are we spending most of our time on? <sup class="footnote-reference"><a href="#1">1</a></sup></p>
<h2 id="allocation-profiling"><a class="header" href="#allocation-profiling">Allocation profiling</a></h2>
<p>Another of async-profilers awesome features is instrumentation free allocation profiling.  This makes it suitable for use in production.  To do this, we simply tell the profiler we are interested in allocations <code>-prof async:output=flamegraph;event=alloc</code>.  If we wanted to, we could do both CPU and allocation profiling in one shot with <code>-prof async:output=flamegraph;event=alloc,cpu</code> </p>
<iframe src="/micro/async/flame-alloc-forward.html" style="width:100%;height:400px;"></iframe>
<p>The allocation sampling works by using TLAB-driven sampling.  While this may result in missing rare allocations in production, its certainty suitable for getting a good idea of what is allocating and where its happening.</p>
<p>Green means java code like last time, but the top level is what was being allocated.  Blue means it was on the <a href="https://dzone.com/articles/thread-local-allocation-buffers">TLAB</a>, also called eden. Brown means it was off the TLAB, which can happen with allocation heavy workloads where Eden can't keep up and for very large allocations.</p>
<p>This tool is not only useful for highlighting where the most allocations are, but also helping us confirm that we actually fixed them.</p>
<h2 id="lock-profiling"><a class="header" href="#lock-profiling">Lock profiling</a></h2>
<p>If you are using a 3rd party library in your critical path, or if you think you may be using locks, it is worth runing async profiler in locking mode.  This mode measure how long various threads are blocked waiting on a lock or monitor.  Enable by running with <code>-prof async:output=flamegraph;event=lock</code> to generate the appropriate data.</p>
<h2 id="alternative-outputs"><a class="header" href="#alternative-outputs">Alternative outputs</a></h2>
<p>Async profiler supports multiple different outputs, depending on your needs.  While I have highlighted flamegraphs above, thats only by personal preference.  You may find other output options more useful in certain contexts.</p>
<p>TODO more context here</p>
<h2 id="reverse-flamegraphs"><a class="header" href="#reverse-flamegraphs">Reverse flamegraphs</a></h2>
<p>While most of us are use to looking at a top down view that most profilers provide.  Reverse flamegraphs flip that on its head.  Instead of merging stacks from the bottom up to the leaf, it aggregates leaves and merges up the call stack. Here is a reverse flamegraph for our same logging benchmark as before.</p>
<iframe src="/micro/async/flame-cpu-reverse.html" style="width:100%;height:400px;"></iframe>
<p>This view is helpful for identifying a performance 'death by a thousand cuts'.  The more paths that lead to particular methods that are hot, the more important this view becomes.  Its usefulness if limited when running unit level benchmarks, but it can excel with multi-unit and component level tests.</p>
<h2 id="some-issues-with-the-profiler"><a class="header" href="#some-issues-with-the-profiler">Some issues with the profiler</a></h2>
<p>No tool is perfect, and here are some limitations with async-profiler.</p>
<h3 id="sampling-isnt-tracing"><a class="header" href="#sampling-isnt-tracing">Sampling isn't tracing</a></h3>
<p>No matter how fast your sample rate is, we are still sampling.  While this data is great and cheap to get, its not quite as detailed as tracing.  Tracing is where a single event's timing is taken throughout the code base.  Tracing has its own challenges, especially around observer impacts, but it can be done in a lightweight way.  This lets you know exactly what events took a while and which didn't.</p>
<p>This ultimately means that profiling can't tell you &quot;What are the modes of service time&quot;.  Its like an average in that respect.  It also can't tell you how far behind you might be in production, or if a particular event took way longer than expected.  So, at the end of the day, it can't help you build a fine grained model for complex systems.</p>
<h3 id="busy-spinning"><a class="header" href="#busy-spinning">Busy spinning</a></h3>
<p>Any busy spinning in the profiled code will skew results.  Creating a common waiting method or set of methods lets you use the <code>exclude</code> option which takes a regular expression.  Using the regex can cause issues. Each stack trace needs to be compared against the regex, which compounds the observer effect.</p>
<p>With that said, there should not be any busy spinning on a JMH benchmark because that implies there is a queue.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Most of our time is being spent inside of JMH code forwarding our stdout to the parent process.  We would not expect this complexity if we were logging to stdout in any real context.  This invalidates our benchmark unless we wanted to specifically test the impact of JMH's output redirection feature.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../micro/coreProfilers/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../micro/ci/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                    <hr>
                    <div>
                        <p>
                            &copy; Erik Helleren, 2021.  Built on 2021-06-08 from commit <code class="hljs">1d1210ef</code>.
                        </p>
                    </div>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../micro/coreProfilers/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../micro/ci/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        
        <script type="text/javascript" src="../../mermaid-init.js"></script>
        

        

    </body>
</html>
